import typing as t
from pathlib import Path
from shlex import quote
from shutil import rmtree

from invoke import Context, task


def run_or_display(c: Context, cmd: str, dry_run: bool):
    if dry_run:
        print(cmd)
    else:
        c.run(cmd)


@task
def clean(
    c: Context,
    docs: bool = False,
    bytecode: bool = False,
    extra: str = "",
    dry_run: bool = False,
):
    """Clean build artifacts and optionally documentation artifacts as well as generated bytecode."""
    patterns = ["dist/*.whl", "dist/*.tar.gz"]
    if docs:
        patterns.append("dist/documentation")
    if bytecode:
        patterns.append("**/*.pyc")
    if extra:
        patterns.append(quote(extra))
    cmd = f"rm -rf {' '.join(patterns)}"
    run_or_display(c, cmd, dry_run=dry_run)


@task
def build(c: Context, docs: bool = False, dry_run: bool = False):
    """Build sdist and wheel, and optionally build documentation."""
    python_build_cmd = ".venv/bin/python -m build --no-isolation --outdir dist ."
    docs_build_cmd = ".venv/bin/python -m mkdocs build -d dist/documentation"
    run_or_display(c, python_build_cmd, dry_run=dry_run)
    if docs:
        if not dry_run:
            rmtree("dist/documentation", ignore_errors=True)
        run_or_display(c, docs_build_cmd, dry_run=dry_run)


@task
def wheelhouse(
    c: Context, clean: bool = False, compress: bool = False, dry_run: bool = False
):
    """Build wheelhouse for the project"""
    wheelhouse_cmd = ".venv/bin/pip wheel . -w dist/wheelhouse"
    compress_cmd = "tar -czf dist/wheelhouse.tar.gz -C dist wheelhouse"
    if not dry_run:
        Path("dist").mkdir(exist_ok=True)
    if clean and not dry_run:
        rmtree("dist/wheelhouse", ignore_errors=True)
    run_or_display(c, wheelhouse_cmd, dry_run=dry_run)
    if not dry_run:
        rmtree("build", ignore_errors=True)
    if compress:
        run_or_display(c, compress_cmd, dry_run=dry_run)


@task
def docs(c: Context, watch: bool = True, port: int = 8000, dry_run: bool = False):
    """Serve the documentation in development mode."""
    cmd = f".venv/bin/python -m mkdocs serve -a localhost:{port}"
    if watch:
        cmd += " --livereload --watch docs/ --watch src"
    run_or_display(c, cmd, dry_run=dry_run)


@task
def test(c: Context, coverage: bool = False, dry_run: bool = False):
    """Run tests using pytest and optionally enable coverage."""
    cmd = ".venv/bin/python -m pytest"
    if coverage:
        cmd += " --cov src"
    run_or_display(c, cmd, dry_run=dry_run)


@task
def coverage(c: Context, run: bool = False, port: int = 8000, dry_run: bool = False):
    """Serve code coverage results and optionally run tests before serving results"""
    if run:
        test(c, True, dry_run=dry_run)
    cmd = f".venv/bin/python -m http.server {port} --dir coverage-report"
    run_or_display(c, cmd, dry_run)


@task
def check(c: Context, include_tests: bool = False, dry_run: bool = False):
    """Run mypy typechecking."""
    cmd = ".venv/bin/python -m mypy src/"
    if include_tests:
        cmd += " tests/"
    run_or_display(c, cmd, dry_run=dry_run)


@task
def format(c: Context, dry_run: bool = False):
    """Format source code using black and isort."""
    run_or_display(c, ".venv/bin/python -m isort .", dry_run=dry_run)
    run_or_display(c, ".venv/bin/python -m black .", dry_run=dry_run)


@task
def lint(c: Context, dry_run: bool = False):
    """Lint source code using flake8."""
    run_or_display(c, ".venv/bin/python -m flake8 .", dry_run=dry_run)


@task
def docker(
    c: Context,
    name: str = "{{ cookiecutter.project_name }}",
    tag: str = "latest",
    registry: t.Optional[str] = None,
    base_image: t.Optional[str] = None,
    push: bool = False,
    build: bool = False,
    dry_run: bool = False,
):
    """Build docker image for the project"""
    if build:
        wheelhouse(c, clean=True, compress=False, dry_run=dry_run)
    image = f"{name}:{tag}"
    if registry:
        while registry.endswith("/"):
            registry = registry[:-1]
        image = f"{registry}/{image}"
    build_args: t.Dict[str, str] = {}
    if base_image:
        build_args["BASE_IMAGE"] = base_image
    cmd = f"docker build -t {image}"
    for key, value in build_args.items():
        cmd += f" --build-arg {key}={value}"
    cmd += " ."
    run_or_display(c, cmd, dry_run=dry_run)
    if push:
        run_or_display(c, f"docker push {image}", dry_run=dry_run)


@task
def docker_cp(
    c: Context,
    platforms: str = "linux/amd64,linux/arm64",
    name: str = "{{ cookiecutter.project_name }}",
    tag: str = "latest",
    registry: t.Optional[str] = None,
    base_image: t.Optional[str] = None,
    build_image: t.Optional[str] = None,
    push: bool = False,
    load: bool = False,
    output: t.Optional[str] = None,
    dry_run: bool = False,
):
    """Build cross-platform docker image for the project"""
    image = f"{name}:{tag}"
    if registry:
        while registry.endswith("/"):
            registry = registry[:-1]
        image = f"{registry}/{image}"
    build_args: t.Dict[str, str] = {}
    if base_image:
        build_args["BASE_IMAGE"] = base_image
    if build_image:
        build_args["BUILD_IMAGE"] = build_image
    cmd = f"docker buildx build -t {image} -f Dockerfile.cross-platform"
    if push:
        cmd += " --push"
    elif load:
        cmd += " --load"
    elif output:
        cmd += f" --output=type=local,dest={output}"
    cmd += f" --platform='{platforms}'"
    for key, value in build_args.items():
        cmd += f" --build-arg {key}={value}"
    cmd += " ."
    run_or_display(c, cmd, dry_run=dry_run)
